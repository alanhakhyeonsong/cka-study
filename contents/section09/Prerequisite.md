## Switching Routing
### 스위치(Switch)
- 동일한 네트워크 내 호스트들을 연결
- 각 호스트는 물리적/가상 인터페이스로 스위치에 연결
- 리눅스 명령어
  - `ip link` : 인터페이스 확인
  - `ip addr` : IP 주소 할당/조회

### 라우터(Router)
- 서로 다른 네트워크 간 통신을 중개
- 라우터는 여러 네트워크 인터페이스와 각각의 IP를 가짐
- 라우터가 없으면 한 네트워크에서 다른 네트워크로 통신 불가

### 게이트웨이(Gateway)
- 라우터의 역할 중 하나
- 네트워크의 "문" 역할
- 호스트는 목적지 네트워크로 가는 "문"을 라우팅 테이블에 설정
- 리눅스 명령어
  - `ip route` : 라우팅 테이블 보기
  - `ip route add` : 새 경로 추가
- 예시
  - 다른 네트워크 접근 위해 게이트웨이 추가
  - `ip route add 192.168.2.0/24 via 192.168.1.1`

### 기본 게이트웨이(Default Gateway)
- "모르는 모든 목적지" 트래픽을 보내는 라우터
- `0.0.0.0/0` 경로를 게이트웨이로 지정
  - `ip route add default via <gateway-ip>`
- 여러 라우터가 있을 수 있음
  - 내부(사설) 네트워크용
  - 인터넷(공용) 네트워크용

### 라우팅 테이블
- 목적지 네트워크 → 게이트웨이 매핑
- 올바른 경로 없으면 패킷 전달 실패
- 문제 해결 시 라우팅 테이블 확인이 중요

### 리눅스 머신을 라우터로 설정하기
- 두 네트워크 인터페이스 가진 호스트가 라우터 역할
- 예: Host B가 A와 C의 네트워크를 연결
- 각 호스트의 라우팅 테이블에 B를 게이트웨이로 추가
- 기본 문제
  - 리눅스는 기본적으로 패킷 포워딩 비활성화
  - 활성화 : `sysctl -w net.ipv4.ip_forward=1`
  - 영구 적용 : `/etc/sysctl.conf`에 추가
    - `net.ipv4.ip_forward=1`

- 스위치는 같은 네트워크 내 통신을 연결하고, 라우터/게이트웨이는 다른 네트워크 간 통신을 연결.
- 리눅스에서는 명령어를 통해 직접 IP와 라우팅 테이블을 설정해 볼 수 있음.
- 포워딩 기능을 켜면 리눅스 호스트가 라우터 역할 가능.

## DNS
### Name Resolution 기본 개념
- 컴퓨터끼리 통신은 IP 주소로 하지만 사람이 기억하기 어려움
- → 이름(호스트명) ↔ IP 주소 변환 필요
- 이를 Name Resolution 라고 함

### /etc/hosts 파일
- 가장 간단한 Name Resolution 방법
- 각 시스템이 로컬 파일을 참조해 이름을 IP로 변환
- 예: `192.168.1.11  db`
- 장점: 간단, 소규모 네트워크에서 유용
- 단점
  - 시스템별로 모두 수동 관리 필요
  - IP 변경 시 모든 서버 수정 필요
  - 중앙 관리 불가
- `/etc/hosts`는 신뢰하지 않아도 무조건 사용 → 거짓 정보도 가능

### DNS 서버
- 중앙 관리형 Name Resolution 서비스
- 모든 호스트가 DNS 서버에 질의 → IP를 반환
- 서버의 IP 변경 시 DNS 서버만 수정하면 됨
- 클라이언트는 `/etc/resolv.conf`에 DNS 서버 IP 지정
  - `nameserver 192.168.1.100`

이름 서버를 여러 개 지정 가능

### Name Resolution 순서
- 호스트가 이름을 해석할 때 순서:
  - 보통 `/etc/hosts` → DNS
  - 순서는 `/etc/nsswitch.conf`에서 지정
- `/etc/hosts`에 있으면 무조건 우선

### 검색 도메인(search domain)
- `/etc/resolv.conf`의 search 항목
  - 간단한 이름 → FQDN으로 자동 완성
    - eg: `search mycompany.com`
    - `ping web` → 실제 질의는 `web.mycompany.com`

### 도메인 이름 구조
- 계층적(트리 구조)
- 예: `www.google.com`
  - `com` : 최상위 도메인(TLD)
  - `google` : 도메인
  - `www` : 서브도메인
- 하위 도메인으로 서비스 구분 가능
  - `mail`, `drive`, `maps` 등

### DNS 레코드 유형
- A : 이름 → IPv4
- AAAA : 이름 → IPv6
- CNAME : 이름 → 이름(별칭)
  - eg: `orders.mycompany.com → app.mycompany.com`

### DNS 서버의 계층적 구조
- 루트 서버 → TLD 서버 → 권한 서버 → 응답
- 조직도 자체 DNS 서버를 운영 가능
  - 내부 서비스 이름 관리
  - 외부 요청은 공용 DNS 서버(8.8.8.8 등)로 전달

### 주요 명령어
- `ping` : Name Resolution + 네트워크 연결 확인
- `nslookup` : DNS 서버 조회 (로컬 hosts는 무시)
- `dig` : 상세한 DNS 쿼리 결과 제공

```
nslookup www.google.com
dig www.google.com
```

정리하자면,
- 소규모 환경 → /etc/hosts로 수동 관리
- 규모 커지면 → 중앙 DNS 서버 필요
- 리눅스는 /etc/resolv.conf, /etc/nsswitch.conf로 DNS 클라이언트 설정

## Core DNS
- DNS 서버가 필요한 이유: 호스트 이름 ↔ IP 주소 매핑을 중앙 관리
- 대규모 환경에서 이름 해석을 효율적으로 처리
- 클라이언트가 사용할 DNS 서버를 어떻게 지정하는지 설명

### CoreDNS 설치
- GitHub 릴리스 페이지나 Docker 이미지에서 구할 수 있음
- 예제에서는 curl/wget으로 바이너리 다운로드 후 압축 해제 → coredns 실행 파일 생성

### CoreDNS 실행
<img width="1473" height="813" alt="Image" src="https://github.com/user-attachments/assets/127d936b-ec60-4f95-90d2-5c67cd0b8235" />

- 기본적으로 포트 53 사용
- 그냥 실행하면 동작은 하지만 → IP/호스트 이름 매핑이 없음

### IP/호스트 이름 매핑 지정
<img width="1408" height="606" alt="Image" src="https://github.com/user-attachments/assets/a4a14c62-6efe-416d-bcd1-5c5417505094" />

- 여러 방법 중 하나
  - 서버의 /etc/hosts 파일에 항목 추가
  - CoreDNS 설정파일(Corefile)에서 이 파일을 읽도록 지정
- Corefile 예제: `/etc/hosts`를 데이터 소스로 사용하도록 설정

정리하자면,
- CoreDNS는 플러그인 기반
- Kubernetes에서 사용하는 플러그인도 있음

## Network Namespaces
### 네임스페이스 개념
- 컨테이너는 호스트에서 분리되도록 네임스페이스를 사용.
- 네임스페이스를 집 안의 방에 비유
  - 각 방(네임스페이스)은 아이(프로세스)에게 사생활을 제공.
  - 아이는 자기 방 안만 볼 수 있고 다른 방을 볼 수 없음.
  - 부모(호스트)는 모든 방을 볼 수 있음.

### 프로세스 네임스페이스
- 컨테이너 내부에서 프로세스 ID는 별도로 관리됨.
- 호스트에서는 모든 프로세스를 볼 수 있지만, 컨테이너는 자기 프로세스만 PID 1로 봄.
- 같은 프로세스라도 컨테이너 안팎에서 PID가 다름

### 네트워크 네임스페이스
- 컨테이너별로 독립된 네트워크 환경 제공.
- 호스트와 분리된
  - 가상 네트워크 인터페이스
  - 라우팅 테이블
  - ARP 테이블
- `ip netns add`로 네임스페이스 생성.
- `ip netns exec` 명령으로 네임스페이스 안에서 명령 실행.
- 각 네임스페이스에서 `ip link` 실행 시 루프백 인터페이스만 보임.

### 네임스페이스 간 연결
- 두 네임스페이스를 가상 이더넷(Veth) 페어로 연결
  - 물리적 케이블처럼 가상 인터페이스 한 쌍 생성.
  - 각 끝을 원하는 네임스페이스에 할당.
  - IP 주소 할당 후 인터페이스 활성화.
  - 서로 핑 가능.

### 다수 네임스페이스 연결
- 두 개 이상 네임스페이스를 연결하려면 가상 스위치(브리지) 필요.
- Linux 브리지를 생성(`ip link add type bridge`).
- 각 네임스페이스의 Veth 한쪽 끝을 브리지에 연결.
- IP 주소를 할당하고 인터페이스를 활성화.
- 모든 네임스페이스가 같은 브리지 네트워크를 통해 통신.

### 호스트와 네임스페이스 간 통신
- 호스트도 브리지에 연결된 인터페이스에 IP 할당.
- 호스트 ↔ 네임스페이스 간 핑 가능.

### 외부 네트워크와 통신
- 네임스페이스 내부에서는 외부 네트워크를 직접 알 수 없음.
- 호스트를 게이트웨이로 설정
  - 네임스페이스의 라우팅 테이블에 호스트를 기본 게이트웨이로 추가.
- NAT 설정(IPTables)
  - 호스트가 네임스페이스의 패킷을 외부 네트워크로 변환해 전달.
  - 네임스페이스가 인터넷에 접속 가능.

### 외부에서 네임스페이스 서비스 접근
- 네임스페이스의 서비스(예: 포트 80 웹서버)는 외부에서 직접 접근 불가.
- 호스트에서 포트 포워딩을 설정
  - 호스트의 특정 포트로 들어온 요청을 네임스페이스의 IP와 포트로 전달.

### 정리
- 네트워크 네임스페이스는 컨테이너의 네트워크 격리를 위해 필수적인 기술로, 호스트 네트워크를 분리된 가상 네트워크처럼 분할해 각 컨테이너가 고유한 네트워크 스택을 갖도록 함.
- 가상 케이블(veth), 브리지, 라우팅, NAT, 포트 포워딩을 활용해 호스트-컨테이너-외부 네트워크 간 연결을 유연하게 설계할 수 있음.

## Docker Networking
### Docker 네트워크 옵션 3가지
- None (no network)
  - 컨테이너가 **아무 네트워크에도 연결되지 않음.**
  - 외부와도, 다른 컨테이너와도 **통신 불가.**
- Host 네트워크
  - 컨테이너가 **호스트의 네트워크 스택을 공유.**
  - 격리 없음 → 컨테이너의 포트 80 = 호스트의 포트 80.
  - 포트 매핑 필요 없음.
  - 동일 포트를 사용하는 컨테이너 여러 개는 동시에 못 띄움.
- Bridge 네트워크 (기본값)
 - Docker가 **호스트 안에 가상 사설 네트워크(Bridge)** 를 생성.
 - 컨테이너는 사설 네트워크(보통 172.17.0.0/16)에 연결.
 - 서로 다른 컨테이너와 호스트는 **이 사설 네트워크에서 자유롭게 통신.**

### Bridge 네트워크의 구조
- Docker 설치 시 자동 생성
  - 이름: `bridge` (Docker 명령어에서)
  - 호스트 인터페이스명: `docker0`
- `docker0`은 Linux 브리지 장치로서,
  - IP 예: 172.17.0.1
  - 컨테이너가 붙는 스위치 역할.
- 호스트에서 `ip link` / `ip addr`로 확인 가능.

### 컨테이너 생성 시 네임스페이스와 인터페이스
- Docker는 컨테이너마다 **고유의 네트워크 네임스페이스**를 생성.
- veth 페어(가상 케이블)를 생성
  - 한쪽 끝은 컨테이너 네임스페이스.
  - 다른 쪽 끝은 브리지(docker0)에 연결.
- 각 컨테이너는 사설 네트워크에서 **고유 IP**를 받음.
  - 예: 172.17.0.3

### 네임스페이스 안의 상태
- 컨테이너 네임스페이스에서
  - `ip link` → 자기 인터페이스만.
  - `ip addr` → 할당된 사설 IP 확인.
- 네임스페이스는 컨테이너 자체와 동의어처럼 사용.

### 다수 컨테이너 간 통신
- 같은 브리지 네트워크에 붙으면 서로 핑 가능.
- Docker0 브리지가 스위치 역할을 하여 통신.

### 외부와의 통신 (포트 매핑)
- 컨테이너는 기본적으로 호스트와 브리지 네트워크를 통해 외부 인터넷에 접속 가능.
- 외부 사용자가 컨테이너의 서비스에 접속하려면 **포트 매핑** 필요
  - 예: Docker 호스트의 8080 → 컨테이너의 80
  - 실행 시 `-p 8080:80` 옵션.
  - 이후 외부에서 `호스트IP:8080`으로 접근.

### Docker의 포트 매핑 내부 작동 방식
- 호스트의 **iptables** NAT 규칙을 이용.
- Docker는 자체 체인과 규칙을 만들어 포트 전달:
  - 외부에서 호스트 8080 → 컨테이너 IP:80.
- iptables 출력에서 Docker가 만든 규칙을 볼 수 있음

## CNI (Container Network Interface)
### Remind
- Linux 네트워크 네임스페이스로 네트워크 격리 구현.
- veth 페어(가상 케이블)로 네임스페이스 연결.
- 브리지 네트워크를 통한 다수 컨테이너 연결.
- IP 할당, NAT(Masquerade) 설정으로 외부 통신 지원.
- Docker의 bridge 네트워크 옵션이 이를 자동화.

### 왜 표준이 필요한가?
- Docker, Rocket, Mesos, Kubernetes 등 모두 같은 네트워킹 문제를 해결해야 함.
- 매번 별도로 네임스페이스 생성, veth 연결, 브리지 설정, IP 할당 코드를 작성해야 하는 비효율성.
- 이를 해결하기 위해 **공통 규약(표준)** 필요.

### CNI의 개념
- **Container Network Interface (CNI)** 는 컨테이너 네트워크 설정을 위한 표준 명세.
- 컨테이너 런타임과 네트워크 플러그인 간의 **명확한 인터페이스(계약)** 을 정의.

### CNI의 동작 원리
- CNI 플러그인은 네트워크 작업을 수행하는 **프로그램**(예: bridge 플러그인).
- 컨테이너 런타임(예: Kubernetes)은 플러그인을 호출해 네트워크 구성
  - **ADD** 명령 → 컨테이너 네임스페이스 생성 후 네트워크 연결.
  - **DEL** 명령 → 컨테이너 삭제 시 네트워크 해제.
- 런타임과 플러그인은 **JSON 구성파일**로 네트워크 정의와 매개변수를 교환.
- 결과(예: 할당된 IP)도 표준화된 형식으로 반환.

### CNI의 플러그인 예
- 공식 플러그인: bridge, VLAN, IPVLAN, MACVLAN, host-local, dhcp 등.
- 커뮤니티/상업 플러그인: Flannel, Calico, Weave, Cilium, VMware NSX 등.

### CNI의 장점
- 런타임과 네트워크 플러그인을 분리 → 플러그인을 교체하거나 확장 가능.
- Kubernetes나 Rocket 같은 런타임에서 어떤 CNI 플러그인도 사용 가능.

### Docker는 왜 다름?
- Docker는 **CNM(Container Network Model)**이라는 자체 표준 사용.
- CNI와 유사한 개념이지만 사양이 달라 호환되지 않음.
- Docker CLI에서는 직접 CNI 플러그인을 지정할 수 없음.

### Kubernetes에서의 사용
- Kubernetes는 Docker를 사용할 때도 CNI를 이용.
- Docker 컨테이너를 네트워크 없음(none) 옵션으로 생성.
- Kubernetes가 CNI 플러그인을 호출해 네트워크를 구성.
